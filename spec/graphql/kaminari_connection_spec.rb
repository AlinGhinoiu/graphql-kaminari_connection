require 'graphql'
require 'kaminari'

RSpec.describe GraphQL::KaminariConnection do
  it 'has a version number' do
    expect(GraphQL::KaminariConnection::VERSION).not_to be nil
  end

  context 'with Kaminari::PaginatableArray' do
    let(:schema) do
      foo_type = Class.new(GraphQL::Schema::Object) do
        include GraphQL::KaminariConnection
        graphql_name 'Foo'
        field :value, 'Int', null: false

        def value
          object
        end
      end

      query_type = Class.new(GraphQL::Schema::Object) do
        graphql_name 'Query'
        field :foos, foo_type.kaminari_connection

        def foos(page: nil, per: nil)
          Kaminari.paginate_array(1.upto(100).to_a).page(page).per(per)
        end
      end

      Class.new(GraphQL::Schema) do
        query query_type
      end
    end

    let(:query) do
      <<~GRAPHQL
        query getFoos($page: Int, $per: Int) {
          foos(page: $page, per: $per) {
            pageData {
              currentPage
              isFirstPage
              isLastPage
              isOutOfRange
              limitValue
              nextPage
              prevPage
              totalPages
            }
            items {
              value
            }
          }
        }
      GRAPHQL
    end

    it 'defines corresponding XxxPage and PageData types' do
      expect(schema.to_definition).to eq <<~GRAPHQL.strip
        type Foo {
          value: Int!
        }

        # Autogenerated page type for Foo
        type FooPage {
          # A list of items
          items: [Foo!]!
          pageData: PageData!
        }

        # Information about pagination
        type PageData {
          currentPage: Int!
          isFirstPage: Boolean!
          isLastPage: Boolean!
          isOutOfRange: Boolean!
          limitValue: Int!
          nextPage: Int
          prevPage: Int
          totalPages: Int!
        }

        type Query {
          foos(page: Int, per: Int): FooPage!
        }
      GRAPHQL
    end

    it 'works' do
      expect(schema.execute(query).to_h).to eq(
        'data' => {
          'foos' => {
            'pageData' => {
              'currentPage' => 1,
              'isFirstPage' => true,
              'isLastPage' => false,
              'isOutOfRange' => false,
              'limitValue' => 25,
              'nextPage' => 2,
              'prevPage' => nil,
              'totalPages' => 4,
            },
            'items' => 1.upto(25).map { |value| Hash['value' => value] }
          }
        }
      )

      expect(schema.execute(query, variables: { page: 2 }).to_h).to eq(
        'data' => {
          'foos' => {
            'pageData' => {
              'currentPage' => 2,
              'isFirstPage' => false,
              'isLastPage' => false,
              'isOutOfRange' => false,
              'limitValue' => 25,
              'nextPage' => 3,
              'prevPage' => 1,
              'totalPages' => 4,
            },
            'items' => 26.upto(50).map { |value| Hash['value' => value] }
          }
        }
      )

      expect(schema.execute(query, variables: { per: 20 }).to_h).to eq(
        'data' => {
          'foos' => {
            'pageData' => {
              'currentPage' => 1,
              'isFirstPage' => true,
              'isLastPage' => false,
              'isOutOfRange' => false,
              'limitValue' => 20,
              'nextPage' => 2,
              'prevPage' => nil,
              'totalPages' => 5,
            },
            'items' => 1.upto(20).map { |value| Hash['value' => value] }
          }
        }
      )

      expect(schema.execute(query, variables: { page: 3, per: 10 }).to_h).to eq(
        'data' => {
          'foos' => {
            'pageData' => {
              'currentPage' => 3,
              'isFirstPage' => false,
              'isLastPage' => false,
              'isOutOfRange' => false,
              'limitValue' => 10,
              'nextPage' => 4,
              'prevPage' => 2,
              'totalPages' => 10,
            },
            'items' => 21.upto(30).map { |value| Hash['value' => value] }
          }
        }
      )
    end
  end
end
